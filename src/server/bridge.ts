import express from 'express';
import cors from 'cors';
import multer from 'multer';
import { EventEmitter } from 'events';
import crypto from 'crypto';
import fs from 'fs/promises';
import path from 'path';
import { info, warn, error, debug, setLogLevel } from '../logger.js';
import { SessionData, SessionListResponse, SessionSelectRequest, SessionSelectResponse } from '../types/session.js';
import { 
  saveSessionData, 
  validateSessionData, 
  getAllSessions, 
  getActiveSessionId, 
  setActiveSessionId, 
  loadSessionById,
  getActiveSession,
  isSessionValid,
  initializeSessionSystem,
  cleanUserName
} from '../utils/sessionHandler.js';
import { VendaBoostAutomation } from '../index.js';

const app = express();
const PORT = parseInt(process.env.BRIDGE_PORT || '49017', 10);

// Event emitter para SSE
const jobEvents = new EventEmitter();

// Configurar multer para upload de imagens
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(process.cwd(), 'uploads');
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `${uniqueSuffix}-${file.originalname}`);
  }
});

const upload = multer({ 
  storage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB por arquivo
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Apenas arquivos de imagem s√£o permitidos'));
    }
  }
});

// Middleware
app.use(cors({
  origin: true,
  credentials: true,
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
app.use(express.json({ limit: '10mb' }));

// Criar diret√≥rio de uploads se n√£o existir
const uploadsDir = path.join(process.cwd(), 'uploads');
fs.mkdir(uploadsDir, { recursive: true }).catch(() => {});

// Tipos para Jobs
interface Job {
  id: string;
  status: 'queued' | 'running' | 'succeeded' | 'failed';
  error?: string;
  createdAt: string;
  updatedAt: string;
  fbUserId: string;
  listing: any;
  groups: string[];
}

interface JobEvent {
  event: 'status' | 'log';
  data: any;
}

interface Session {
  fbUserId: string;
  lastUpdated: string;
}

// Armazenamento em mem√≥ria (em produ√ß√£o usar Redis/PostgreSQL)
const jobs = new Map<string, Job>();
const jobLogs = new Map<string, Array<{msg: string, ts: string}>>();

// GET /healthz ‚Üí "ok"
app.get('/healthz', (req, res) => {
  res.send('ok');
});

// POST /upload ‚Üí recebe upload de imagens
app.post('/upload', upload.array('images', 10), (req, res) => {
  try {
    info('üì∑ [BRIDGE] Recebendo requisi√ß√£o de upload de imagens...');
    const files = req.files as Express.Multer.File[];
    
    info(`üì∑ [BRIDGE] Arquivos recebidos: ${files ? files.length : 0}`);
    
    if (!files || files.length === 0) {
      warn('üì∑ [BRIDGE] ‚ùå Nenhum arquivo enviado na requisi√ß√£o');
      return res.status(400).json({
        success: false,
        error: 'Nenhum arquivo enviado'
      });
    }

    info(`üì∑ [BRIDGE] Processando ${files.length} arquivos...`);
    
    const uploadedFiles = files.map((file, index) => {
      const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
      info(`üì∑ [BRIDGE] Arquivo ${index + 1}/${files.length}:`);
      info(`üì∑ [BRIDGE]   - Nome original: ${file.originalname}`);
      info(`üì∑ [BRIDGE]   - Nome salvo: ${file.filename}`);
      info(`üì∑ [BRIDGE]   - Caminho: ${file.path}`);
      info(`üì∑ [BRIDGE]   - Tamanho: ${fileSizeMB} MB`);
      info(`üì∑ [BRIDGE]   - Tipo: ${file.mimetype}`);
      
      return {
        originalName: file.originalname,
        filename: file.filename,
        path: file.path,
        size: file.size,
        mimetype: file.mimetype
      };
    });

    info(`üì∑ [BRIDGE] ‚úÖ Upload realizado com sucesso: ${uploadedFiles.length} imagens`);
    info(`üì∑ [BRIDGE] ‚úÖ Caminhos salvos: ${uploadedFiles.map(f => f.path).join(', ')}`);

    return res.json({
      success: true,
      files: uploadedFiles
    });

  } catch (err) {
    error('üì∑ [BRIDGE] ‚ùå Erro cr√≠tico no upload:', err);
    return res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    });
  }
});

// POST /session ‚Üí recebe sess√£o da extens√£o e salva localmente
app.post('/session', async (req, res) => {
  try {
    const sessionData: SessionData = req.body;
    
    info('üì• Dados de sess√£o recebidos da extens√£o', {
      userId: sessionData.userId,
      cookiesCount: sessionData.cookies?.length || 0
    });

    // Validar dados da sess√£o
    const validation = validateSessionData(sessionData);
    if (!validation.isValid) {
      error('‚ùå Dados de sess√£o inv√°lidos:', validation.errors);
      return res.status(400).json({
        success: false,
        error: 'Dados de sess√£o inv√°lidos',
        details: validation.errors
      });
    }

    // Salvar dados da sess√£o
    await saveSessionData(sessionData);
    
    info('‚úÖ Dados de sess√£o salvos com sucesso');

    return res.json({
      success: true,
      message: 'Sess√£o salva com sucesso'
    });

  } catch (err) {
    error('‚ùå Erro ao salvar sess√£o:', err);
    return res.status(500).json({
      success: false,
      error: 'Erro interno do servidor',
      details: err instanceof Error ? err.message : 'Erro desconhecido'
    });
  }
});

// GET /sessions ‚Üí lista sess√µes salvas
app.get('/sessions', async (req, res) => {
  try {
    const sessionsDir = path.join(process.cwd(), 'data', 'sessions');
    
    // Verificar se o diret√≥rio existe
    try {
      await fs.access(sessionsDir);
    } catch {
      return res.json([]);
    }

    const files = await fs.readdir(sessionsDir);
    const sessions: Session[] = [];

    for (const file of files) {
      if (file.endsWith('.json')) {
        try {
          const filePath = path.join(sessionsDir, file);
          const stats = await fs.stat(filePath);
          const content = await fs.readFile(filePath, 'utf-8');
          const sessionData = JSON.parse(content);
          
          sessions.push({
            fbUserId: sessionData.userId || sessionData.facebookId || 'unknown',
            lastUpdated: stats.mtime.toISOString()
          });
        } catch (err) {
          warn(`Erro ao ler sess√£o ${file}:`, err);
        }
      }
    }

    return res.json(sessions);
  } catch (err) {
    error('‚ùå Erro ao listar sess√µes:', err);
    return res.status(500).json({
      success: false,
      error: 'Erro ao listar sess√µes'
    });
  }
});

// Session management endpoints (new API compatible with frontend)

// GET /api/sessions - List all available sessions
app.get('/api/sessions', async (req, res) => {
  try {
    info('üìã [BRIDGE] Requisi√ß√£o para listar sess√µes dispon√≠veis');
    
    const sessions = await getAllSessions();
    const activeSessionId = await getActiveSessionId();
    
    const response: SessionListResponse = {
      success: true,
      sessions,
      activeSessionId: activeSessionId
    };
    
    info(`‚úÖ [BRIDGE] Retornando ${sessions.length} sess√µes dispon√≠veis`);
    return res.json(response);
    
  } catch (err) {
    error('‚ùå [BRIDGE] Erro ao listar sess√µes:', err);
    return res.status(500).json({
      success: false,
      sessions: [],
      error: 'Erro interno do servidor'
    });
  }
});

// GET /api/sessions/active - Get currently active session info
app.get('/api/sessions/active', async (req, res) => {
  try {
    info('üîç [BRIDGE] Requisi√ß√£o para obter sess√£o ativa');
    
    // Use getActiveSession() which has proper fallback logic
    const activeSessionData = await getActiveSession();
    
    if (!activeSessionData) {
      return res.json({
        success: true,
        message: 'Nenhuma sess√£o ativa dispon√≠vel',
        activeSession: undefined
      });
    }
    
    // Get the session info by finding it in the sessions list
    const sessions = await getAllSessions();
    
    // Try to find by active session ID first, then by user ID as fallback
    const activeSessionId = await getActiveSessionId();
    let activeSession = activeSessionId ? sessions.find(s => s.id === activeSessionId) : null;
    
    // If not found by ID, try to find by user ID (fallback scenario)
    if (!activeSession && activeSessionData.userId) {
      activeSession = sessions.find(s => s.userId === activeSessionData.userId);
    }
    
    if (!activeSession) {
      // Create a session info object from the session data if we can't find it in the list
      activeSession = {
        id: activeSessionId || 'current',
        userId: activeSessionData.userId,
        userName: cleanUserName(activeSessionData.userInfo?.name),
        timestamp: activeSessionData.timestamp,
        isActive: true,
        isValid: isSessionValid(activeSessionData),
        filePath: ''
      };
    }
    
    info(`‚úÖ [BRIDGE] Sess√£o ativa: ${activeSession.userName} (${activeSession.userId})`);
    return res.json({
      success: true,
      activeSession,
      message: 'Sess√£o ativa obtida com sucesso'
    });
    
  } catch (err) {
    error('‚ùå [BRIDGE] Erro ao obter sess√£o ativa:', err);
    return res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    });
  }
});

// POST /api/sessions/select - Select active session
app.post('/api/sessions/select', async (req, res) => {
  try {
    const { sessionId }: SessionSelectRequest = req.body;
    
    if (!sessionId) {
      return res.status(400).json({
        success: false,
        message: 'sessionId √© obrigat√≥rio',
        activeSession: undefined
      });
    }
    
    info(`üéØ [BRIDGE] Requisi√ß√£o para selecionar sess√£o: ${sessionId}`);
    
    // Verify session exists and is valid
    const sessionData = await loadSessionById(sessionId);
    if (!sessionData) {
      return res.status(404).json({
        success: false,
        message: 'Sess√£o n√£o encontrada ou inv√°lida',
        activeSession: undefined
      });
    }
    
    // Set as active session
    await setActiveSessionId(sessionId);
    
    // Get updated session info
    const sessions = await getAllSessions();
    const activeSession = sessions.find(s => s.id === sessionId);
    
    const response: SessionSelectResponse = {
      success: true,
      message: `Sess√£o ativa alterada para: ${cleanUserName(sessionData.userInfo?.name) || sessionId}`,
      activeSession: activeSession!
    };
    
    info(`‚úÖ [BRIDGE] Sess√£o ativa definida: ${cleanUserName(sessionData.userInfo?.name)} (${sessionData.userId})`);
    return res.json(response);
    
  } catch (err) {
    error('‚ùå [BRIDGE] Erro ao selecionar sess√£o:', err);
    return res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: err instanceof Error ? err.message : 'Erro desconhecido',
      activeSession: undefined
    });
  }
});

// POST /jobs/marketplace.publish ‚Üí cria um job
app.post('/jobs/marketplace.publish', async (req, res) => {
  try {
    const { fbUserId, listing, groups } = req.body;
    
    if (!fbUserId || !listing || !groups) {
      return res.status(400).json({
        success: false,
        error: 'Par√¢metros obrigat√≥rios: fbUserId, listing, groups'
      });
    }

    const jobId = crypto.randomUUID();
    const now = new Date().toISOString();
    
    const job: Job = {
      id: jobId,
      status: 'queued',
      createdAt: now,
      updatedAt: now,
      fbUserId,
      listing,
      groups
    };

    jobs.set(jobId, job);
    jobLogs.set(jobId, []);
    
    info(`üìã Job criado: ${jobId}`, { fbUserId, groups: groups.length });
    
    // Iniciar processamento do job em background
    processJob(jobId).catch(err => {
      error(`‚ùå Erro ao processar job ${jobId}:`, err);
    });

    return res.json({
      id: jobId,
      status: 'queued'
    });

  } catch (err) {
    error('‚ùå Erro ao criar job:', err);
    return res.status(500).json({
      success: false,
      error: 'Erro ao criar job'
    });
  }
});

// GET /jobs/:id ‚Üí status do job
app.get('/jobs/:id', (req, res) => {
  const { id } = req.params;
  const job = jobs.get(id);
  
  if (!job) {
    return res.status(404).json({
      success: false,
      error: 'Job n√£o encontrado'
    });
  }

  return res.json({
    id: job.id,
    status: job.status,
    error: job.error,
    createdAt: job.createdAt,
    updatedAt: job.updatedAt
  });
});

// GET /events?jobId=... ‚Üí SSE com eventos
app.get('/events', (req, res): any => {
  const jobId = req.query.jobId as string;
  
  if (!jobId) {
    return res.status(400).json({
      error: 'jobId √© obrigat√≥rio'
    });
  }

  if (!jobs.has(jobId)) {
    return res.status(404).json({
      error: 'Job n√£o encontrado'
    });
  }

  info(`üì° [SSE] Nova conex√£o estabelecida para job ${jobId}`);

  // Configurar SSE com headers mais robustos
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache, no-store, must-revalidate',
    'Connection': 'keep-alive',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Cache-Control',
    'X-Accel-Buffering': 'no', // Nginx
    'Transfer-Encoding': 'chunked'
  });

  // Enviar evento inicial com status atual
  const job = jobs.get(jobId)!;
  const statusEvent = {
    id: job.id,
    status: job.status,
    error: job.error
  };
  res.write(`event: status\ndata: ${JSON.stringify(statusEvent)}\n\n`);

  // Enviar logs existentes
  const logs = jobLogs.get(jobId) || [];
  logs.forEach(log => {
    res.write(`event: log\ndata: ${JSON.stringify(log)}\n\n`);
  });

  // Listener para novos eventos com error handling
  const eventListener = (event: JobEvent) => {
    if (event.data.jobId === jobId) {
      try {
        if (!res.destroyed && !res.writableEnded) {
          res.write(`event: ${event.event}\ndata: ${JSON.stringify(event.data)}\n\n`);
        }
      } catch (err) {
        warn(`Erro ao enviar evento SSE para job ${jobId}:`, err);
        cleanup();
      }
    }
  };

  // Keep-alive mais frequente (10 segundos)
  const keepAlive = setInterval(() => {
    try {
      if (!res.destroyed && !res.writableEnded) {
        res.write(': keep-alive\n\n');
      } else {
        cleanup();
      }
    } catch (err) {
      warn(`Erro no keep-alive SSE para job ${jobId}:`, err);
      cleanup();
    }
  }, 10000);

  // Fun√ß√£o de cleanup
  const cleanup = () => {
    try {
      info(`üì° [SSE] Conex√£o encerrada para job ${jobId}`);
      jobEvents.removeListener('job-event', eventListener);
      clearInterval(keepAlive);
      if (!res.destroyed && !res.writableEnded) {
        res.end();
      }
    } catch (err) {
      debug('Erro durante cleanup SSE:', err);
    }
  };

  jobEvents.on('job-event', eventListener);

  // Cleanup quando conex√£o fechar
  req.on('close', cleanup);
  req.on('error', cleanup);
  res.on('error', cleanup);
});

// Fun√ß√£o para processar job
async function processJob(jobId: string) {
  const job = jobs.get(jobId);
  if (!job) return;

  try {
    // Atualizar status para running
    job.status = 'running';
    job.updatedAt = new Date().toISOString();
    jobs.set(jobId, job);
    
    // Emitir evento de status
    jobEvents.emit('job-event', {
      event: 'status',
      data: {
        jobId,
        id: job.id,
        status: job.status
      }
    });

    // Adicionar log inicial
    addJobLog(jobId, 'Iniciando publica√ß√£o no marketplace...');
    
    // Carregar dados da sess√£o
    const sessionData = await loadSessionData(job.fbUserId);
    if (!sessionData) {
      throw new Error(`Sess√£o n√£o encontrada para usu√°rio ${job.fbUserId}`);
    }

    addJobLog(jobId, 'Sess√£o carregada com sucesso');
    addJobLog(jobId, `Publicando em ${job.groups.length} grupos`);

    // Executar automa√ß√£o real
    try {
      // Configurar logs para debug e redirecionar para job
      setLogLevel('debug');
      
      const automation = new VendaBoostAutomation();
      
      // Converter dados do job para formato do flow
      const images = job.listing.images || [];
      
      // Log detalhado sobre as imagens
      addJobLog(jobId, `üì∑ [JOB] Imagens recebidas: ${images.length}`);
      if (images.length > 0) {
        addJobLog(jobId, `üì∑ [JOB] Caminhos das imagens: ${images.join(', ')}`);
        
        // Verificar se os arquivos existem
        for (let i = 0; i < images.length; i++) {
          const imagePath = images[i];
          try {
            await fs.access(imagePath);
            const stats = await fs.stat(imagePath);
            const fileSizeMB = (stats.size / (1024 * 1024)).toFixed(2);
            addJobLog(jobId, `üì∑ [JOB] ‚úÖ Imagem ${i + 1}/${images.length}: ${imagePath} (${fileSizeMB} MB)`);
          } catch (err) {
            addJobLog(jobId, `üì∑ [JOB] ‚ùå Imagem ${i + 1}/${images.length} n√£o encontrada: ${imagePath}`);
          }
        }
      } else {
        addJobLog(jobId, 'üì∑ [JOB] ‚ö†Ô∏è Nenhuma imagem ser√° enviada para o marketplace');
      }
      
      const flowData = {
        title: job.listing.title,
        price: job.listing.price,
        category: job.listing.category,
        description: job.listing.description,
        condition: job.listing.condition,
        location: job.listing.location,
        images: images
      };
      
      const config = {
        autoExtension: true,
        debug: false,  // Desativado para fechar browser automaticamente
        headless: true,  // Browser oculto
        throttleMs: 350
      };
      
      addJobLog(jobId, 'üöÄ Iniciando automa√ß√£o do marketplace...');
      addJobLog(jobId, `üìã Dados do an√∫ncio: ${flowData.title} - R$ ${flowData.price}`);
      addJobLog(jobId, `üìã Categoria: ${flowData.category} | Condi√ß√£o: ${flowData.condition}`);
      addJobLog(jobId, `üì∑ Imagens para upload: ${images.length}`);
      
      // Logs diretos para debug - removendo delays
      addJobLog(jobId, 'üîç TESTE: Antes de executar a automa√ß√£o real', 'debug');
      
      addJobLog(jobId, 'üì§ Executando automa√ß√£o real do Playwright...', 'marketplace');
      addJobLog(jobId, `üîß Config da automa√ß√£o: headless=${config.headless}, debug=${config.debug}`, 'debug');
      addJobLog(jobId, `üìã FlowData enviado: ${JSON.stringify(flowData)}`, 'debug');
      
      try {
        const result = await automation.runFlow({
          flowData,
          config,
          groupNames: job.groups
        });
        
        addJobLog(jobId, `üìä Resultado da automa√ß√£o: success=${result.success}`, 'debug');
        addJobLog(jobId, `üìä Mensagem: ${result.message || 'Sem mensagem'}`, 'debug');
        addJobLog(jobId, `üìä Error: ${result.error || 'Sem erro'}`, 'debug');
        
        if (!result.success) {
          throw new Error(result.error || 'Automa√ß√£o falhou sem erro espec√≠fico');
        }
        
        addJobLog(jobId, `‚úÖ Automa√ß√£o conclu√≠da: ${result.message}`, 'marketplace');
      } catch (automationError) {
        addJobLog(jobId, `‚ùå ERRO na automa√ß√£o: ${automationError}`, 'error');
        throw automationError;
      }
      
    } catch (automationError) {
      throw new Error(`Falha na automa√ß√£o: ${automationError instanceof Error ? automationError.message : 'Erro desconhecido'}`);
    }

    // Job conclu√≠do com sucesso
    job.status = 'succeeded';
    job.updatedAt = new Date().toISOString();
    jobs.set(jobId, job);
    
    addJobLog(jobId, 'üéâ Publica√ß√£o conclu√≠da com sucesso!');
    
    // Emitir evento final
    jobEvents.emit('job-event', {
      event: 'status',
      data: {
        jobId,
        id: job.id,
        status: job.status
      }
    });

  } catch (err) {
    // Job falhou
    job.status = 'failed';
    job.error = err instanceof Error ? err.message : 'Erro desconhecido';
    job.updatedAt = new Date().toISOString();
    jobs.set(jobId, job);
    
    addJobLog(jobId, `‚ùå Erro: ${job.error}`);
    
    // Emitir evento de erro
    jobEvents.emit('job-event', {
      event: 'status',
      data: {
        jobId,
        id: job.id,
        status: job.status,
        error: job.error
      }
    });
  }
}

// Fun√ß√£o para adicionar log ao job com componente espec√≠fico
function addJobLog(jobId: string, message: string, component: string = 'automation') {
  const logs = jobLogs.get(jobId) || [];
  const logEntry = {
    msg: message,
    ts: new Date().toISOString(),
    component
  };
  
  logs.push(logEntry);
  jobLogs.set(jobId, logs);
  
  // Emitir evento de log
  jobEvents.emit('job-event', {
    event: 'log',
    data: {
      jobId,
      ...logEntry
    }
  });
  
  info(`[Job ${jobId}] ${message}`);
}

// Fun√ß√£o para carregar dados da sess√£o
async function loadSessionData(fbUserId: string): Promise<SessionData | null> {
  try {
    const sessionsDir = path.join(process.cwd(), 'data', 'sessions');
    const files = await fs.readdir(sessionsDir);
    
    for (const file of files) {
      if (file.endsWith('.json')) {
        const filePath = path.join(sessionsDir, file);
        const content = await fs.readFile(filePath, 'utf-8');
        const sessionData = JSON.parse(content);
        
        if (sessionData.userId === fbUserId || sessionData.facebookId === fbUserId) {
          return sessionData;
        }
      }
    }
    
    return null;
  } catch (err) {
    error('Erro ao carregar dados da sess√£o:', err);
    return null;
  }
}

// Iniciar servidor
export function startBridge(): Promise<void> {
  return new Promise(async (resolve, reject) => {
    try {
      // Inicializar sistema de sess√µes
      await initializeSessionSystem();
      
      const server = app.listen(PORT, '127.0.0.1', () => {
        info(`üåâ Bridge API iniciado em http://127.0.0.1:${PORT}`);
        info('üì° Endpoints dispon√≠veis:');
        info('  GET /healthz');
        info('  POST /upload');
        info('  POST /session');
        info('  GET /sessions');
        info('  POST /jobs/marketplace.publish');
        info('  GET /jobs/:id');
        info('  GET /events?jobId=...');
        resolve();
      });

      server.on('error', (err) => {
        if ((err as any).code === 'EADDRINUSE') {
          error(`‚ùå Porta ${PORT} j√° est√° em uso`);
          reject(new Error(`Porta ${PORT} j√° est√° em uso`));
        } else {
          reject(err);
        }
      });
    } catch (err) {
      error('‚ùå Erro ao inicializar Bridge API:', err);
      reject(err);
    }
  });
}

// Graceful shutdown
process.on('SIGTERM', () => {
  info('üõë Encerrando Bridge API...');
  process.exit(0);
});

process.on('SIGINT', () => {
  info('üõë Encerrando Bridge API...');
  process.exit(0);
});

export default app;